import { Injectable } from '@angular/core';
import { ItemDataService } from '@dspace/core/data/item-data.service';
import { Collection } from '@dspace/core/shared/collection.model';
import { DSpaceObject } from '@dspace/core/shared/dspace-object.model';
import { followLink } from '@dspace/core/shared/follow-link-config.model';
import { Item } from '@dspace/core/shared/item.model';
import { getFirstSucceededRemoteDataPayload } from '@dspace/core/shared/operators';
import { Vocabulary } from '@dspace/core/submission/vocabularies/models/vocabulary.model';
import { VocabularyService } from '@dspace/core/submission/vocabularies/vocabulary.service';
import { isNotEmpty } from '@dspace/shared/utils/empty.util';
import {
  Observable,
  of,
} from 'rxjs';
import { switchMap } from 'rxjs/operators';

/**
 * A service containing all the common logic for the components generated by the
 * {@link DsoEditMetadataValueFieldLoaderComponent}.
 */
@Injectable({
  providedIn: 'root',
})
export class DsoEditMetadataFieldService {

  constructor(
    protected itemService: ItemDataService,
    protected vocabularyService: VocabularyService,
  ) {
  }

  /**
   * Find the vocabulary of the given {@link mdField} for the given item.
   *
   * @param dso The item
   * @param mdField The metadata field
   */
  findDsoFieldVocabulary(dso: DSpaceObject, mdField: string): Observable<Vocabulary> {
    if (isNotEmpty(mdField)) {
      const owningCollection$: Observable<Collection> = this.itemService.findByHref(dso._links.self.href, true, true, followLink('owningCollection')).pipe(
        getFirstSucceededRemoteDataPayload(),
        switchMap((item: Item) => item.owningCollection),
        getFirstSucceededRemoteDataPayload(),
      );

      return owningCollection$.pipe(
        switchMap((c: Collection) => this.vocabularyService.getVocabularyByMetadataAndCollection(mdField, c.uuid).pipe(
          getFirstSucceededRemoteDataPayload(),
        )),
      );
    } else {
      return of(undefined);
    }
  }
}
